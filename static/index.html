<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Um passeio por Go</title>

<!-- jQuery -->
<script src="static/jquery.js"></script>

<!-- CodeMirror -->
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/lib/go.js"></script>

<!-- Tour -->
<link rel="stylesheet" href="static/tour.css">
<script src="static/mode.js"></script>
<script src="static/tour.js"></script>

</head>
<body>
	<div id="wrap">
		<div id="header">
			<div id="slidenum">1</div>
				<a href="#toc" id="tocbtn" title="Índice analítico"></a>
				<h1>Um passeio por Go</h1>
			</div>

			<div id="slides" class="slides"><!-- begin slides -->

<div class="slide">
	<h2>Olá, 世界</h2>
	<p>
	Bem-vindo a um passeio pela 
	<a target="_blank" href="http://golang.org/">Linguagem de Programação Go</a>.
	<p>
	O passeio é dividido em três seções. No final de cada seção há uma série de exercícios para você completar.
	<p>
	O passeio é interativo. Clique no botão Executar agora (ou pressione Shift-Enter) para compilar e executar o programa em <span class="appengineMode">um servidor remoto.</span><span class="localMode">seu computador.</span>
	O resultado é exibido abaixo do código.
	<p>
  	Estes programas exemplo demonstrarão os diferentes aspectos de Go. Os programas do passeio são feitos para serem pontos de partida para a sua própria experimentação.  
        <p>
	Edite o programa e execute-o novamente.
	<p>
	Sempre que você estiver pronto para seguir em frente, clique no botão Próximo ou pressione a tecla PageDown.
<pre class="source">package main

import "fmt"

func main() {
	fmt.Println("Olá, 世界")
}</pre>
</div>

<div class="slide nocode appengineMode">
	<h2>Go local</h2>
	<p>
	O passeio também está disponível em outras línguas:
	<ul>
	<li><a href="http://tour.golang.org/">Inglês &mdash; English</a></li>
	<li><a href="http://go-tour-cn.appspot.com/">Chinês &mdash; 普通话</a></li>
	<li><a href="http://go-tour-jp.appspot.com/">Japonês &mdash; 日本語</a></li>
	</ul>
	<p>
	(Se você quiser traduzir o passeio para outra lingua, dê uma olhada no
	código-fonte de <code>https://code.google.com/p/go-tour</code>, 
	traduza <code>static/index.html</code>, e então suba-o para AppEngine
	usando as instruções em <code>appengine/README</code>.)
	Clique no botão "próximo" ou aperte PageDown para continuar.
</div>

<div class="slide nocode appengineMode">
	<h2>Go offline</h2>
	<p>
	Este passeio também está disponível como um programa stand-alone, que você pode usar sem acesso à internet.
	<p>
	O passeio stand-alone é mais rápido, já que os exemplos de código são construídos e executados em sua própria máquina. Ele também inclui exercícios adicionais que não estão disponíveis nesta versão no modo seguro.
	<p>
	Para executar o passeio localmente primeiro
	<a target="_blank" href="http://golang.org/doc/install/">instale Go</a>,
	então use
	<a target="_blank" href="http://golang.org/cmd/go/">go get</a> para instalar
  <a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>:
  <pre>    go get code.google.com/p/go-tour/gotour</pre>
  <p>
  ou a versão em <a href="https://github.com/danielvargas/go-tour-br" target="_blank">português do Brasil</a>
	<pre>    go get github.com/danielvargas/go-tour-br/gotour</pre>
	<p>
	e execute o binário resultante <code>gotour</code>.
	<p>
	Caso contrário, clique no botão "Próximo" ou pressione PageDown para continuar.
	<p>
	<i>(Você pode voltar a estas instruções a qualquer momento, clicando no botão "Índice".)</i>
</div>

<div class="toc">Introdução</div>

<div class="slide">
	<h2>Pacotes</h2>
	<p>
	Cada programa Go é composto de pacotes.
	<p>
	Programas começam rodando pelo pacote <code>main</code>.
	<p>
	Este programa está usando os pacotes com caminhos de importação
	<code>"fmt"</code> e <code>"math"</code>.
	<p>
	Por convenção, o nome do pacote é o mesmo que o último elemento do caminho de importação.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Dia", math.Pi, "Feliz")
}</pre>
</div>

<div class="slide">
	<h2>Importações</h2>
	<p>
	Este grupo de códigos em parênteses da importação, é a declaração de importação "consignada". Você também pode escrever várias declarações de importação assim: 
	<pre>
	import "fmt"
	import "math"</pre>
	mas é comum usar a forma consignada para eliminar a desordem.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Agora você têm %g problemas.",
		math.Nextafter(2, 3))
}</pre>
</div>

<div class="slide">
	<h2>Nomes exportados</h2>
	<p>
	Depois de importar um pacote, você pode consultar os nomes que exporta.
	<p>
	Em Go, um nome é exportado se começa com uma letra maiúscula.
	<p>
	<code>Foo</code>  é um nome exportado, assim como <code>FOO</code>.
	O nome <code>foo</code> não é exportado.
	<p>
	Execute o código. Em seguida, renomeie <code>math.pi</code> para <code>math.Pi</code>
	e tente novamente.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	A função pode ter zero ou mais argumentos.
	<p>
	Neste exemplo, <code>adicione</code> dois parâmetros do tipo <code>int</code>.
	<p>
	Observe que o tipo vem <i>após</i> o nome da variável.
	<p>
	(Para saber mais sobre o porquê dos tipos serem assim, consulte o <a target="_blank" href="http://golang.org/doc/articles/gos_declaration_syntax.html">artigo sobre a sintaxe de declaração de Go</a>.)
<pre class="source">package main

import "fmt"

func adicione(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(adicione(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	Quando dois ou mais consecutivos parâmetros da função nomeados compartilhar um tipo, você pode omitir o tipo de todos, menos o último.
	<p>
	Neste exemplo, vamos encurtar
	<pre>x int, y int</pre>
	<p>
	para
	<pre>x, y int</pre>
<pre class="source">package main

import "fmt"

func adicione(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(adicione(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	Uma função pode retornar qualquer número de resultados.
	<p>
	Esta função retorna duas strings.
<pre class="source">package main

import "fmt"

func troque(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := troque("olá", "mundo")
	fmt.Println(a, b)
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	Funções têm parâmetros. Em Go as funções podem retornar vários "parâmetros de resultado", e não apenas um único valor. 
	Eles podem ser nomeados e atuam como variáveis.
	<p>
	Se os parâmetros de resultado são nomeados, uma  declaração <code>return</code> sem argumentos retorna os valores atuais dos resultados.
<pre class="source">package main

import "fmt"

func separe(soma int) (x, y int) {
	x = soma * 4/9
	y = soma - x
	return
}

func main() {
	fmt.Println(separe(17))
}</pre>
</div>

<div class="slide">
	<h2>Variáveis</h2>
	<p>
	A instrução <code>var</code> declara uma lista de variáveis, como em listas de argumentos de função, o tipo é passado.

<pre class="source">package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Variáveis</h2>
	<p>
	A declaração var pode incluir inicializadores, uma por variável.
	<p>
	Se um inicializador está presente, o tipo pode ser omitido; a variável terá o tipo do inicializador.
<pre class="source">package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "não!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Variáveis</h2>
	<p>
	Dentro de uma função, a instrução de atribuição curta <code>:=</code> pode ser utilizada em lugar de uma declaração <code>var</code> com o tipo implícito.
	<p>
	(Fora de uma função, cada estrutura começa com uma palavra-chave e <code>:=</code> não está disponível)
<pre class="source">package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "não!"

	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Constantes</h2>
	<p>
	Constantes são declaradas como variáveis, mas com a palavra-chave <code>const</code>.
	<p>
	Constantes podem ser seqüências de caracteres, booleanos, ou valores numéricos.
<pre class="source">package main

import "fmt"

const Pi = 3.14

func main() {
	const Mundo = "世界"
	fmt.Println("Olá", Mundo)
	fmt.Println("Dia", Pi, "Feliz")

	const Verdade = true
	fmt.Println("Go é legal?", Verdade)
}</pre>
</div>

<div class="slide">
	<h2>Constantes Numéricas</h2>
	<p>
	As constantes numéricas são <i>valores</i> de alta precisão.
	<p>
	Uma constante sem tipo tem o tipo necessário para o seu contexto.
	<p>
	Tente imprimir <code>precisadeInt(Grande)</code> também.
<pre class="source">package main

import "fmt"

const (
	Grande = 1&lt;&lt;100
	Pequeno = Grande>>99
)

func precisadeInt(x int) int { return x*10 + 1 }
func precisadeFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(precisadeInt(Pequeno))
	fmt.Println(precisadeFloat(Pequeno))
	fmt.Println(precisadeFloat(Grande))
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go tem apenas uma estrutura de laço, o <code>for</code>.
	<p>
	O <code>for</code> básico parece com o que o de C ou Java fazem, 
	exceto que as <code>( )</code> se foram (não são nem mesmo opcionais) e os <code>{ }</code> são obrigatórios.
<pre class="source">package main

import "fmt"

func main() {
	soma := 0
	for i := 0; i &lt; 10; i++ {
		soma += i
	}
	fmt.Println(soma)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Como em C ou Java, você pode deixar as declarações do começo e do final vazias.
<pre class="source">package main

import "fmt"

func main() {
	soma := 1
	for ; soma &lt; 1000; {
		soma += soma
	}
	fmt.Println(soma)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Nesse ponto, você pode tirar as vírgulas:
	o <code>while</code> do C é escrito com <code>for</code> em Go.
<pre class="source">package main

import "fmt"

func main() {
	soma := 1
	for soma &lt; 1000 {
		soma += soma
	}
	fmt.Println(soma)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Se você omitir a condição do laço, ele executará infinitamente.
<pre class="source">package main

func main() {
	for ; ; {
	}
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	E sem cláusulas em tudo o ponto-e-vírgula pode ser omitido, e um loop infinito é compactadamente expresso.
<pre class="source">package main

func main() {
	for {
	}
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	A declaração <code>if</code> parece com o que o de C ou Java fazem, 
	exceto que as <code>( )</code> se foram (não são nem mesmo opcionais) e os <code>{ }</code> são obrigatórios.
	<p>
	(Parece familiar?)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x &lt; 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Como o <code>for</code>, a instrução <code>if</code> pode começar com uma breve declaração antes de executar a condição.
	<p>
	Variáveis ​​declaradas pela instrução são válidas somente no escopo até o final do <code>if</code>.
	<p>
	(Tente usar <code>v</code> na última instrução <code>return</code>.)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Variáveis ​​declaradas dentro de uma instrução <code>if</code> curta também estão
	disponíveis dentro dos blocos <code>else</code>.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// Não pode usar v aqui, pense
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>Tipos básicos</h2>
	<p>
	Os tipos básicos de Go são
	<pre>
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias para uint8

rune // alias para int32
     // Representa um ponto de código Unicode

float32 float64

complex64 complex128</pre>
<pre class="source">package main

import (
	"math/cmplx"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1&lt;&lt;64 - 1
	z complex128 = cmplx.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}</pre>
</div>

<div class="slide">
	<h2>Structs</h2>
	<p>
	A <code>struct</code> é uma coleção de campos.
	<p>
	(E uma declaração <code>type</code> faz o que você esperaria.)
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}</pre>
</div>

<div class="slide">
	<h2>Campos Struct</h2>
	<p>
	Campos Struct são acessados ​​através de um ponto.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}</pre>
</div>

<div class="slide">
	<h2>Ponteiros</h2>
	<p>
	Go tem ponteiros, mas não a aritmética de ponteiros.
	<p>
	Campos struct podem ser acessados ​​através de um ponteiro struct. A indireção através do ponteiro é transparente.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &amp;p
	q.X = 1e9
	fmt.Println(p)
}</pre>
</div>

<div class="slide">
	<h2>Struct literais</h2>
	<p>
	A struct literal denota um valor struct recém-alocado, ao enumerar os valores de seus campos.
	<p>
	Você pode listar apenas um subconjunto de campos usando o <code>Name:</code>
	sintaxe. (E a ordem dos campos nomeados é irrelevante.)
	<p>
	O prefixo especial <code>&amp;</code> constrói um ponteiro para uma struct 
	literal.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // tem tipo Vertex
	q = &amp;Vertex{1, 2} // tem tipo *Vertex
	r = Vertex{X: 1}  // Y:0 é implícito
	s = Vertex{}      // X:0 e Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}</pre>
</div>

<div class="slide">
	<h2>A função <code>new</code></h2>
	<p>
	A expressão <code>new(T)</code> aloca um valor zerado para <code>T</code>
	e retorna um ponteiro para ele.
	<pre>var t *T = new(T)</pre>
	<p>
	or
	<pre>t := new(T)</pre>
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}</pre>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Um map mapeia chaves para valores.
	<p>
	<!-- TODO: empty part not true in compilers yet -->
	Maps devem ser criados com <code>make</code> (não com <code>new</code>)
	antes do uso, o map <code>nil</code> está vazio e não pode ser atribuído.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, 74.39967,
	}
	fmt.Println(m["Bell Labs"])
}</pre>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Map literais são como struct literais, mas as chaves são obrigatórias.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Se o tipo de nível superior é apenas um nome do tipo, você pode omiti-lo a partir dos elementos 
	do literal.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Mutação de Mapas</h2>
	<p>
	Inserir ou atualizar um elemento no map <code>m</code>:
	<pre>m[key] = elem</pre>
	<p>
	Recuperar um elemento:
	<pre>elem = m[key]</pre>
	<p>
	Excluir um elemento:
	<pre>delete(m, key)</pre>
	<p>
	Teste que uma chave está presente com dois valores:
	<pre>elem, ok = m[key]</pre>
	<p>
	Se <code>key</code> está em <code>m</code>,
	<code>ok</code> é <code>true</code>.
	Se não, <code>ok</code> é <code>false</code> e
	<code>elem</code> tem valor zero pro elemento tipo do map.
	<p>
	Da mesma forma, durante a leitura de um mapa se a chave não estiver presente, 
	o resultado é o valor zero para o tipo de mapa do elemento.
<pre class="source">package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Resposta"] = 42
	fmt.Println("The value:", m["Resposta"])

	m["Resposta"] = 48
	fmt.Println("The value:", m["Resposta"])

	delete(m, "Resposta")
	fmt.Println("The value:", m["Resposta"])

	v, ok := m["Resposta"]
	fmt.Println("O valor:", v, "Existe?", ok)
}</pre>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Um slice aponta para uma matriz de valores e também inclui um comprimento.
	<p>
	<code>[]T</code> é um slice com elementos do tipo <code>T</code>.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i &lt; len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}</pre>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Slices podem ser redimencionadas, criando um valor de uma nova slice que aponta para a 
	mesma matriz.
	<p>
	A expressão
	<pre>s[lo:hi]</pre>
	<p>
	avalia para uma slice de elementos de <code>lo</code> através de
	<code>hi-1</code>, inclusive. Assim
	<pre>s[lo:lo]</pre>
	<p>
	é vazia e
	<pre>s[lo:lo+1]</pre>
	<p>
	tem um elemento.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// faltando baixo índice implica 0
	fmt.Println("p[:3] ==", p[:3])

	// falta implica alto índice len(s)
	fmt.Println("p[4:] ==", p[4:])
}</pre>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Slices são criados com a função <code>make</code>. Ele funciona através
	da atribuição de uma matriz zerada e retornando uma slice que se refere a essa 
	matriz:
	<pre>
a := make([]int, 5)  // len(a)=5</pre>
	Slices têm comprimento e capacidade. A capacidade de uma slice é o comprimento máximo 
	da slice, podendo crescer dentro da matriz subjacente.
	<p>
	Para especificar uma capacidade, passe um terceiro argumento para <code>make</code>:
	<p>
	<pre>
b := make([]int, 0, 5)
// len(b)=0, cap(b)=5</pre>
	Slices podem crescer por "re-slicing" (até sua capacidade):
	<p>
	<pre>
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4</pre>
<pre class="source">package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}</pre>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	O valor zero de uma slice é <code>nil</code>.
	<p>
	Uma slice nil tem um comprimento e capacidade de 0.
	<p>
	(Para saber mais sobre as slices, leia o artigo  
	"<a target="_blank" href="http://golang.org/doc/articles/slices_usage_and_internals.html">Slices: internamente e usos</a>"
	.)
<pre class="source">package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("nil!")
	}
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	Funções são valores também.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}</pre>
</div>

<div class="slide">
	<h2>Funções</h2>
	<p>
	E as funções são closures completos.
	<p>
	A função <code>somador</code> retorna um closure. 
	Cada closure é obrigado a própria variável <code>soma</code>.
<pre class="source">package main

import "fmt"

func somador() func(int) int {
	soma := 0
	return func(x int) int {
		soma += x
		return soma
	}
}

func main() {
	pos, neg := somador(), somador()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}</pre>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	O <code>range</code> do laço <code>for</code>
	itera sobre uma slice ou map.
<pre class="source">package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
	    fmt.Printf("2**%d = %d\n", i, v)
	}
}</pre>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	Você pode ignorar a variável chave ou de valor, atribuindo o <code>_</code>.
	<p>
	Se você só quiser o índice, deixe inteiramente sem o   
	&ldquo;<code>, valor </code>&rdquo;.
<pre class="source">package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}</pre>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Você provavelmente sabia que o <code>switch</code> estava chegando.
	<p>
	O bloco case falhará automaticamente, a menos que termine com uma declaração <code>fallthrough</code>.
<pre class="source">package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go está rodando em ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}</pre>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Switch cases avaliam casos de cima para baixo, parando quando um 
	caso for bem-sucedido.
	<p>
	(Por exemplo,
	<pre>
switch i {
case 0:
case f():
}</pre>
	<p>
	não chamar <code>f</code> se <code>i==0</code>.)

<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Quando é sábado?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today+0:
		fmt.Println("Hoje.")
	case today+1:
		fmt.Println("Amanhã.")
	case today+2:
		fmt.Println("Em dois dias.")
	default:
		fmt.Println("Está bem longe.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Switch sem uma condição é o mesmo que <code>switch true</code>.
	<p>
	Essa estrutura pode ser uma maneira limpa para escrever longas cadeias if-then-else.
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
	    fmt.Println("Bom dia!")
	case t.Hour() < 17:
	    fmt.Println("Boa tarde.")
	default:
	    fmt.Println("Boa noite.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Laços e Funções</h2>
	<p>
	Como uma forma simples de brincar com as funções e laços, implemente a função de raiz quadrada 
	usando o método de Newton.
	<p>
	Neste caso, o método de Newton é aproximar <code>Sqrt(x)</code>
	, escolhendo um ponto de partida <i>z</i> e depois repetindo:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^2-x}{2z}">
	</center>
	<p>
	Para começar, basta repetir esse cálculo 10 vezes e ver o quão perto você chega à resposta para 
	vários valores (1, 2, 3, ...).
	<p>
	Em seguida, altere a condição do laço para parar uma vez que o valor deixou de mudar (ou apenas 
	mudanças por um delta muito pequeno). Veja se isso são muitas ou poucas iterações. 
	Como ainda falta para o <a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a>?
	<p>
	Dica: para declarar e inicializar um valor de ponto flutuante, dê-lhe a sintaxe de ponto 
	flutuante ou use uma conversão:
	<pre>
	z := float64(1)
	z := 1.0</pre>

<pre class="source">package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Maps</h2>
	<p>
	Implementar <code>ContadordePalavras</code>. Ele deve retornar um map das contagens de cada
	&ldquo;word&rdquo; na string <code>s</code>.
	A função <code>wc.Test</code> executa um conjunto de testes contra a função fornecida e 
	imprime o sucesso ou fracasso.
	<p>
	Você pode achar <a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a> útil.

<pre class="source">package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/wc"
)

func ContadordePalavras(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(ContadordePalavras)
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Slices</h2>
	<p>
	Implemente <code>Pic</code>. Ela deve retornar uma slice de comprimento 
	<code>dy</code>, cada elemento do qual é uma slice de <code>dx</code>
	8-bit inteiros sem sinal. Quando você executa o programa, ele irá exibir a 
	sua imagem, interpretando os números inteiros como escala dos valores de cinza (bem, bluescale).
	<p>
	A escolha da imagem é com você. 
	Funções interessantes incluem <code>x^y</code>, <code>(x+y)/2</code>, e <code>x*y</code>.
	<p>
	(Você precisa usar um loop para alocar cada <code>[]uint8</code> dentro
	do <code>[][]uint8</code>.)
	<p>
	(Utilize <code>uint8(intValue)</code> para converter entre os tipos.)

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Fibonacci closure</h2>
	<p>
	Vamos nos divertir um pouco com as funções.
	<p>
	Implemente uma função <code>fibonacci</code> que retorna uma função (um closure) que retorna números sucessivos de Fibonacci.

<pre class="source">package main

import "fmt"

// fibonacci é uma função que retorna
// função que retorna um int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}</pre>
</div>

<div class="slide">
	<h2>Exercício Avançado: raízes cúbicas complexas</h2>
	<p>
	Vamos explorar o apoio do Go built-in para os números complexos através dos tipos
	<code>complex64</code> e <code>complex128</code>.
	Para raízes cúbicas, o método de Newton equivale a repetir:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^3-x}{3z^2}">
	</center>
	<p>
	Encontre a raiz cúbica de 2, só para ter certeza de que o algoritmo funciona. 
	Há uma função <a target="_blank" href="http://golang.org/pkg/math/cmplx/#Pow">Pow</a>
	no pacote <code>math/cmplx</code>.

<pre class="source">package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}</pre>
</div>


<div class="toc">Métodos e Interfaces</div>

<div class="slide nocode">
<h2>Métodos e Interfaces</h2>
</div>

<div class="slide">
	<h2>Métodos</h2>
	<p>
	Go não tem classes. No entanto, você pode definir métodos em 
	tipos struct.
	<p>
	O <i>método receptor</i> aparece em sua lista de argumentos entre a própria
	palavra-chave <code>func</code> e o nome do método.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	fmt.Println(v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Métodos</h2>
	<p>
	Na verdade, você pode definir um método em <i>qualquer</i> tipo que você definir em seu pacote, 
	e não apenas estruturas.
	<p>
	Você não pode definir um método em um tipo de um outro pacote, ou em um 
	tipo básico.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Métodos com ponteiro receptor</h2>
	<p>
	Os métodos podem ser associados com um tipo nomeado ou um ponteiro 
	para um tipo nomeado.
	<p>
	Nós só vimos dois métodos <code>Abs</code>. Um no tipo ponteiro
	<code>*Vertex</code> e outro no valor do tipo
	<code>MeuFloat</code>.
	<p>
	Há duas razões para usar um receptor de ponteiro. 
	Primeiro, para evitar copiar o valor de cada chamada de método 
	(mais eficiente se o tipo de valor é uma estrutura grande). 
	Em segundo lugar, de modo que o método possa modificar o valor 
	que o seu receptor aponta.
	<p>
	Tente mudar as declarações dos métodos <code>Abs</code> e
	<code>Scale</code> para usar <code>Vertex</code> como o receptor, 
	ao invés de <code>*Vertex</code>.
	<p>
	O método <code>Scale</code> não tem efeito sobre <code>v</code> é um
	<code>Vertex</code>. <code>Scale</code> muda <code>v</code>. Quando
	<code>v</code> é um tipo valor (não-ponteiro), o método vê uma cópia do
	<code>Vertex</code> e não pode sofrer mutação do valor original.
	<p>
	<code>Abs</code> funciona de qualquer maneira. Ele apenas lê <code>v</code>.
	Não importa se ele está lendo o valor original 
	(através de um ponteiro) ou uma cópia desse valor.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	Um tipo de interface é definida por um conjunto de métodos.
	<p>
	Um valor de tipo de interface pode conter qualquer valor que 
	implementa esses métodos.

<pre class="source">package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MeuFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // o MeuFloat implementa Abser
	a = &amp;v // a *Vertex implementa Abser
	a = v  // um Vertex, NÃO
	       // implementa Abser

	fmt.Println(a.Abs())
}

type MeuFloat float64

func (f MeuFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</pre>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	Um tipo implementa uma interface através da implementação dos métodos.
	<p>
	<i>Não há declaração explícita de intenções.</i>
	<p>
	As interfaces implícitas dissociam os pacotes de implementação
	que definem as interfaces: um não depende do outro.
	<p>
	Além disso, incentiva a definição de interfaces precisas, porque você 
	não tem que encontrar todas as implementações e marcá-las com o novo 
	nome de interface.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">Pacote io</a> define <code>Reader</code> e <code>Writer</code>; você não precisa implementar.
<pre class="source">package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err error)
}

type Writer interface {
	Write(b []byte) (n int, err error)
}

type LeiaEscritor interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout implementa Escritor
	w = os.Stdout

	fmt.Fprintf(w, "olá, escritor\n")
}</pre>
</div>

<div class="slide">
	<h2>Erros</h2>
	<p>
	Um erro é algo que pode descrever-se como uma string de erro. 
	A idéia é capturada pela predefinida interface built-in, o tipo <code>error</code>,
	com seu método único <code>Error</code>, retornando uma string:
	<pre>type error interface {
	Error() string
}</pre>

	<p>
	As várias rotinas de impressão no pacote <code>fmt</code> que automaticamente
	sabe chamar o método quando solicitado a imprimir um <code>error</code>.

<pre class="source">package main

import (
	"fmt"
	"time"
)

type MeuErro struct {
	When time.Time
	What string
}

func (e *MeuErro) Error() string {
	return fmt.Sprintf("em %v, %s",
		e.When, e.What)
}

func run() error {
	return &amp;MeuErro{
		time.Now(),
		"isso não funciona",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}</pre>
</div>

<div class="slide">
	<h2>Servidores Web</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/net/http/">Pacote http</a> serve solicitações HTTP usando qualquer valor 
	que implementa <code>http.Handler</code>:
	<pre>package http

type Handler interface {
	ServeHTTP(w ResponseWriter,
	          r *Request)
}</pre>
	<p>
	Neste exemplo, o tipo <code>Olá</code> implementa <code>http.Handler</code>.
	<p>
	<span class="localMode">
	Visite <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> para ver a saudação.
	</span>
	<span class="appengineMode">
	<b>Nota:</b> Este exemplo não será executado através da interface de usuário baseado no passeio pela web. 
	Para tentar escrever servidores web que você pode querer  
	<a target="_blank" href="http://golang.org/doc/install/">Instale 
	Go</a>.
	</span>
<pre class="source">package main

import (
	"fmt"
	"net/http"
)

type Olá struct{}

func (h Olá) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "Olá!")
}

func main() {
	var h Olá
	http.ListenAndServe("localhost:4000",h)
}</pre>
</div>

<div class="slide">
	<h2>Imagens</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">Pacote image</a> define a interface <code>Imagem</code>:
	<pre>
package image

type Imagem interface {
	ColorModel() color.Model
	Bounds() Rectangle
	At(x, y int) color.Color
}</pre>
	<p>
	(Veja <a target="_blank" href="http://golang.org/pkg/image/#Image">a 
	documentação</a> para todos os detalhes.)
	<p>
	Além disso, <code>color.Color</code> e <code>color.Model</code> são interfaces,
	mas vamos ignorar isso usando as implementações predefinidas
	<code>color.RGBA</code> e <code>color.RGBAModel</code>.

<pre class="source">package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Erros</h2>
	<p>
	Copie o sua função <code>Sqrt</code> dos exercícios anteriores e modifique-o para retornar um valor de <code>error</code>.
	<p>
	<code>Sqrt</code> deve retornar um valor de erro não-nil quando recebe um número 
	negativo, pois não suporta números complexos.
	<p>
	Crie um novo tipo
	<pre>
type ErroNegativoSqrt float64</pre>
	<p>
	e faça-o dar <code>error</code>, dando-lhe um
	<pre>
func (e ErroNegativoSqrt) Error() string</pre>
	<p>
	tal método que <code>ErroNegativoSqrt(-2).Error()</code> retorne
	<code>"Sqrt não pode usar número negativo: -2"</code>.
	<p>
	<b>Nota:</b> uma chamada para <code>fmt.Print(e)</code> dentro do método
	<code>Error</code> irá enviar o programa em um laço infinito. Você pode 
	evitar isso através da conversão <code>e</code> em primeiro lugar: 
	<code>fmt.Print(float64(e))</code>. Por que?
	<p>
	Mude sua função <code>Sqrt</code> para retornar um valor
	<code>ErroNegativoSqrt</code> quando receber um número negativo.
<pre class="source">package main

import (
	"fmt"
)

func Sqrt(f float64) (float64, error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}</pre>
</div>

<div class="slide localMode">
	<h2>Exercício: manipuladores HTTP</h2>
	<p>
	Implementar os seguintes tipos e definir métodos ServeHTTP sobre eles. 
	Registrá-los para lidar com caminhos específicos no seu servidor web.
<pre>type String string
	
type Struct struct {
	Saudação  string
	Pontuação string
	Quem      string
}</pre>
	<p>
	Por exemplo, você deve ser capaz de registrar manipuladores usando:
<pre>http.Handle("/string", String("Paca, tatu. "))
http.Handle("/struct", &amp;Struct{"Olá", ":", "Gophers!"})</pre>
<pre class="source">package main

import (
	"net/http"
)

func main() {
	// seu http.Handle é usado aqui
	http.ListenAndServe("localhost:4000", nil)
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Imagens</h2>
	<p>
	Lembre-se o gerador de imagem que escrevi anteriormente? 
	Vamos escrever outro, mas desta vez ele irá retornar uma 
	implementação de <code>image.Image</code> em vez de uma slice de dados.
	<p>
	Definir a seu próprio tipo <code>Image</code>, implemente
	<a href="http://golang.org/pkg/image/#Image" target="_blank">os métodos necessários</a>,
	e chame <code>pic.ShowImage</code>.
	<p>
	<code>Bounds</code> deve retornar um <code>image.Rectangle</code>, como
	<code>image.Rect(0, 0, w, h)</code>.
	<p>
	<code>ColorModel</code> deve retornar <code>color.RGBAModel</code>.
	<p>
	<code>At</code> deve retornar uma cor;
	o valor <code>v</code> no gerador última imagem corresponde a 
	<code>color.RGBA{v, v, 255, 255}</code> em um presente.

<pre class="source">package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Leitor Rot13</h2>
	<p>
	Um padrão comum é um
	<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a> que envolve 
	outro <code>io.Reader</code>, modificando o fluxo de alguma forma.
	<p>
	Por exemplo, a função
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#NewReader">gzip.NewReader</a>
	recebe um <code>io.Reader</code> (um fluxo de dados compactado) 
	e retorna um <code>*gzip.Reader</code> que também implementa
	<code>io.Reader</code> (um fluxo de dados descomprimidos).
	<p>
	Implemente um <code>Leitorrot13</code> que implementa um
	<code>io.Reader</code> que leia a partir de um <code>io.Reader</code>,
	modificando o fluxo através da aplicação da cifra
	<a target="_blank" href="http://en.wikipedia.org/wiki/ROT13">ROT13</a>
	de substituição para todos os caracteres alfabéticos.
	<p>
	O tipo <code>Leitorrot13</code> é fornecido para você. Você deve torná-lo um
	<code>io.Reader</code> através da implementação de seu método <code>Read</code>.
<pre class="source">package main

import (
	"io"
	"os"
	"strings"
)

type Leitorrot13 struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Ibpr dhroebh b pbqvtb!")
	r := Leitorrot13{s}
	io.Copy(os.Stdout, &amp;r)
}</pre>
</div>

<div class="toc">Concorrência</div>

<div class="slide nocode">
<h2>Concorrência</h2>
</div>

<div class="slide">
	<h2>Goroutines</h2>
	<p>
	Uma <i>goroutine</i> é um segmento leve e gerenciado pelo runtime de Go.
	<pre>go f(x, y, z)</pre>
	<p>
	inicia uma nova execução goroutine
	<pre>f(x, y, z)</pre>
	<p>
	A avaliação
        de <code>f</code>, <code>x</code>, <code>y</code>, e <code>z</code>
        acontece na goroutine corrente e para a execução de f 
        acontece em uma goroutine nova.
	<p>
	Goroutines executam no mesmo espaço de endereço, para que o acesso à memória compartilhada 
	seja sincronizada. O pacote de <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sincronia</a></code> fornece as primitivas úteis, embora você não vá precisar muito deles 
	em Go, pois há outras primitivas. 
	(Veja o próximo slide).
<pre class="source">package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100 * time.Millisecond)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("mundo")
	say("olá")
}</pre>
</div>

<div class="slide">
	<h2>Canais</h2>

	<p>
	Canais são um conduto tipado através do qual você pode enviar e receber valores com o operador de canal, <code>&lt;-</code>.
<pre>
ch &lt;- v    // v envia para o canal ch.
v := &lt;-ch  // Recebe do ch, e
           // atribui o valor de v
</pre>
	<p>
	(Os dados fluem na direção da seta.)

	<p>
	Como maps e slices, os canais devem ser criados antes de se usar:
<pre>
ch := make(chan int)
</pre>

	<p>
	Por padrão, enviam e recebem bloco até o outro lado estar pronto. 
	Isso permite que goroutines sincronizem sem bloqueios explícitos ou 
	variáveis ​​de condição.
<pre class="source">package main

import "fmt"

func soma(a []int, c chan int) {
	soma := 0
	for _, v := range a {
		soma += v
	}
	c &lt;- soma  // envia soma para c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
	go soma(a[:len(a)/2], c)
	go soma(a[len(a)/2:], c)
        x, y := &lt;-c, &lt;-c  // recebe de c

	fmt.Println(x, y, x + y)
}</pre>
</div>


<div class="slide">
	<h2>Canais Bufferizados</h2>
	
	<p>
	Os canais podem ser <i>bufferizados</i>. Fornecendo o tamanho do buffer como o 
	segundo argumento para <code>make</code> para inicializar um canal bufferizado:
<pre>
ch := make(chan int, 100)
</pre>

	<p>
	Envia para um bloco de canais bufferizados apenas quando o buffer está cheio. 
	Recebe bloco quando o buffer está vazio.

	<p>
	Modifique o exemplo, enchendo o buffer e veja o que acontece.

<pre class="source">package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}</pre>
</div>

<div class="slide">
	<h2>Range e Close</h2>
	<p>
	Um remetente pode <code>close</code> um canal para indicar que os valores não serão mais enviados. 
	Receptores podem testar se um canal foi fechado através da atribuição de um segundo parâmetro para 
	a expressão de recepção: depois
	<pre>
v, ok := &lt;-ch</pre>
	<p>
	<code>ok</code> é <code>false</code> se não há mais valores a receber e o canal está fechado.
	<p>
	O laço <code>for i := range c</code>  recebe valores do 
	canal repetidamente até que seja fechado.
	<p>
	<b>Nota:</b> Apenas o remetente deve fechar um canal, nunca o 
	receptor. O envio em um canal fechado irá causar um pânico.
	<p>
	<b>Outra nota</b>: Canais não são como arquivos, você geralmente não precisa fechá-los. O encerramento só é 
	necessário quando o receptor precisa saber que não há mais valores chegando, como para terminar um 
	laço <code>range</code>.
<pre class="source">package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
        x, y := 1, 1
        for i := 0; i < n; i++ {
                c <- x
                x, y = y, x + y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
	go fibonacci(cap(c), c)
        for i := range c {
                fmt.Println(i)
        }
}</pre>
</div>

<div class="slide">
	<h2>Select</h2>
	<p>
	A instrução <code>select</code> permite uma espera na goroutine sobre as operações de 
	comunicação múltiplas.
	<p>
	O bloco <code>select</code> aguarda até que um de seus cases possam executar, então ele executa esse case. 
	Ele escolhe um ao acaso se vários estiverem prontos.
<pre class="source">package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c &lt;- x:
			x, y = y, x + y
		case &lt;-quit:
			fmt.Println("sair")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i &lt; 10; i++ {
			fmt.Println(&lt;-c)
		}
		quit &lt;- 0
	}()
	fibonacci(c, quit)
}</pre>
</div>

<div class="slide">
	<h2>Selection Padrão</h2>
	<p>
	O case <code>default</code> em um <code>select</code>  é executado se nenhum 
	outro caso está pronto.
	<p>
	Utilize um case <code>default</code> para tentar um enviar ou receber sem 
	bloqueio:
	<pre>
select {
case i := &lt;-c:
	// use i
default:
	// Recebendo c bloquearia
}</pre>
	<p>
	<span class="appengineMode">
	<b>Nota:</b> Este exemplo não será executado através da interface de usuário baseada 
	no passeio web porque o ambiente sandbox não tem noção de tempo. Você pode querer
	<a target="_blank" href="http://golang.org/doc/install/">instalar Go</a>
	para ver este exemplo em ação.
	</span>
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	tick := time.Tick(1e8)
	boom := time.After(5e8)
	for {
		select {
		case &lt;-tick:
			fmt.Println("tick.")
		case &lt;-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(5e7)
		}
	}
	}</pre>
</div>

<div class="slide nocode">
	<h2>Exercício: árvores binárias equivalentes</h2>
	<p>
	Pode haver muitas árvores binárias diferentes com a mesma seqüência de valores armazenados nas folhas. 
	Por exemplo, aqui estão duas árvores binárias que armazenam a seqüência 1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png">
	<p>
	A função para verificar se duas árvores binárias armazenam a mesma seqüência é bastante complexa, 
	na maioria das linguagens. Vamos usar a simultaneidade de Go e canais para escrever uma solução simples.
	<p>
	Este exemplo utiliza o pacote <code>tree</code>, o qual define o tipo:
<pre>type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}</pre>
</div>

<div class="slide">
	<h2>Exercício: árvores binárias equivalentes</h2>
	<p>
	<b>1.</b> . Implementar a função <code>Ande</code>.
	<p>
	<b>2.</b> Testar a função <code>Ande</code>.
	<p>
	A função <code>tree.New(k)</code> constrói uma árvore binária 
	aleatoriamente estruturada segurando os valores <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code>.
	<p>
	Crie um novo canal <code>ch</code> e lance o andarilho:
<pre>
go Ande(tree.New(1), ch)
</pre>
	<p>
	Então leia e imprima 10 valores do canal. 
	Deve ser os números 1, 2, 3, ..., 10.
	<p>
	<b>3.</b>  Implementar a função <code>Mesma</code> usando <code>Ande</code>
	para determinar se <code>t1</code> e <code>t2</code> armazenam os mesmos valores.
	<p>
	<b>4.</b> Teste a função <code>Mesma</code>.
	<p>
	<code>Mesma(tree.New(1), tree.New(1))</code> deve retornar true, e
	<code>Mesma(tree.New(1), tree.New(2))</code> deve retornar false.

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/tree"

// Ande percorre a árvore t e envia todos os valores
// da árvore para o ch canal.
func Ande(t *tree.Tree, ch chan int)

// Mesma determina se as árvores
// t1 e t2 contém os mesmos valores
func Mesma(t1, t2 *tree.Tree) bool

func main() {
}</pre>
</div>

<div class="slide">
	<h2>Exercício: Web Crawler</h2>
	<p>
	Neste exercício, você vai usar os recursos da concorrência de Go para 
	paralelizar um web crawler.
	<p>
	Modifique a função <code>Crawl</code> para buscar URLs em paralelo, 
	sem buscar a mesma URL duas vezes.
<pre class="source">package main

import (
	"fmt"
)

type Fetcher interface {
	// Buscar retorna o corpo de URL e
	// um slice de URLs encontradas nessa página.
	Fetch(url string) (body string, urls []string, err error)
}

// Crawl usa fetcher recursivamente crawl
// pages começando com URL, a um máximo de profundidade.
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: Buscar URLs em paralelo.
	// TODO: Não buscar a mesma URL duas vezes.
	// Esta implementação não faz nda:
	if depth <= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher é o Fetcher que retorna os resultados.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("não encontrado: %s", url)
}

// fetcher é o fakeFetcher "populado".
var fetcher = &amp;fakeFetcher{
	"http://golang.org/": &amp;fakeResult{
		"The Go Programming Language",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &amp;fakeResult{
		"Packages",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &amp;fakeResult{
		"Package fmt",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &amp;fakeResult{
		"Package os",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}</pre>
</div>

<div class="slide nocode">
	<h2>Para onde ir a partir daqui ...</h2>
	<p class="appengineMode">
	Você pode começar por
	<a href="http://golang.org/doc/install/">instalando Go</a> ou baixar o
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engine SDK</a>.
	</p>
	<p>
	<span class="appengineMode">Uma vez que você tenha Go em sua máquina, </span>
	<span class="localMode">A</span>
	<a target="_blank" href="http://golang.org/doc/">Documentação de Go</a> é um ótimo lugar para  
	<span class="appengineMode">continuar</span>
	<span class="localMode">começar</span>.
	Ele contém referências, tutoriais, vídeos, e muito mais.
	<p>
	Se precisar de ajuda com a biblioteca padrão, consulte a
	<a target="_blank" href="http://golang.org/pkg/">referência de pacotes</a>. 
	Para obter ajuda com a linguagem em si, você pode ser surpreendido ao encontrar a 
	<a target="_blank" href="http://golang.org/ref/spec">Especificação da Linguagem</a>, é bastante legível.
	<p>
	Para explorar ainda mais a concorrência no modelo de Go, consulte a
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">Memória Compartilhada por Comunicação</a>
	codewalk.
	<p>
	As <a target="_blank" href="http://golang.org/doc/codewalk/functions/">Primeira Funções de Classe em Go</a>
	codewalk dá uma perspectiva interessante sobre tipos de funções em Go.
	<p>
	O <a target="_blank" href="http://blog.golang.org/">Go Blog</a>
	tem um grande arquivo de artigos informativos de Go.
	<p>
	Visite <a target="_blank" href="http://golang.org">golang.org</a> para mais.
</div>

</div><!-- end slides -->

<div id="workspace">
	<div class="controls">
		<div><a id="run" href="#run" title="Compile and Run">Executar</a><a href="#more" id="more" title="Options">▼</a></div>
		<ul class="more">
			<li><a href="#" id="reset">Reset Slide</a></li>
			<li><a href="#" id="format">Formatar código-fonte</a></li>
			<li><a href="#" id="kill" class="localMode">Matar Programa</a></li>
			<li><hr></li>
			<li><a href="#" id="togglesyntax">Syntax-Highlighting: desligado</a></li>
			<li><a href="#" id="togglelineno">Números de linha: ligado</a></li>
		</ul>
	</div>

	<div id="workspace-top">
		<div id="workspace-editor">
			<textarea id="editor" spellcheck="false"></textarea>
		</div>
	</div>

	<div id="workspace-bottom">
		<div id="output"></div>
	</div>
</div>
</div>

</body>
</html>
