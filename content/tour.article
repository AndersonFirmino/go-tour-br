Um passeio por Go

Os Autores de Go
http://golang.org

# Throughout this file are a series of lines that begin with
# the string "#appengine: ". These lines are included in
# the tour content when deployed as an App Engine app.
# Furthermore, a single non-blank line that immediately follows
# a run of "#appengine: " lines will be hidden. This is so that
# App Engine-specific content may replace existing content.
# For example, this paragraph
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# reads as "We are running on App Engine. Yay!" on App Engine,
# and "We are running locally. Yay!" otherwise.

* Olá, 世界

Bem-vindo a um passeio pela [[http://golang.org/][Linguagem de Programação Go]].

O passeio é dividido em três seções: conceitos básicos, métodos e interfaces, e concorrência.

No final de cada seção há uma série de exercícios para você completar.

O passeio é interativo. Clique no botão Executar agora (ou pressione Shift-Enter) para compilar e executar o programa em
#appengine: um servidor remoto.
seu computador.
O resultado é exibido abaixo do código.

Estes programas exemplo demonstrarão os diferentes aspectos de Go. Os programas do passeio são feitos para serem pontos de partida para a sua própria experimentação.

Edite o programa e execute-o novamente.

Sempre que você estiver pronto para seguir em frente, clique na seta para direita ou pressione a tecla PageDown.
Você também pode navegar usando o menu do marcador "Go" no topo da página.

.play prog/tour/hello.go

* Go local

O passeio também está disponível em outras línguas:

- [[http://go-tour-ca.appspot.com/][Catalão — Català]]
- [[http://go-tour-zh.appspot.com/][Chinês — 普通话]]
- [[http://go-tour-es.appspot.com/][Espanhol — Español]]
- [[http://go-tour-fr.appspot.com/][Francês - Français]]
- [[http://go-tour-he.appspot.com/][Hebraico — עִבְרִית]]
- [[http://tour.golang.org/][Inglês — English]]
- [[http://go-tour-jp.appspot.com/][Japonês — 日本語]]
- [[http://go-tour-kr.appspot.com/][Koreano — 한국어]]
- [[http://go-tour-ro.appspot.com/][Romeno - Română]]
- [[http://tur.golang.org.tr/][Turco - Türkçe]]

#appengine: * O Playground Go
#appengine:
#appengine: Este passeio foi construído sobre o [[http://play.golang.org/][Go Playground]], um
#appengine: serviço web executado sobre servidores de [[http://golang.org/][golang.org]].
#appengine:
#appengine: O serviço recebe um programa Go, compila, linka, e executa o programa dentro
#appengine: de uma "sandbox", em seguida, devolve o resultado.
#appengine:
#appengine: Existem limitações para os programas que podem ser executados no playground:
#appengine:
#appengine: - O playground pode usar a maior parte da biblioteca padrão, com algumas exceções, notadamente ausentes são as partes de rede e acesso ao sistema de arquivos. Portanto, a única comunicação de um programa no playground tem para o mundo exterior é escrevendo para a saída padrão e erro padrão.
#appengine: - No playground, o horário começa em 2009-11-10 23:00:00 UTC (o significado da determinação desta data é um exercício para o leitor). Isto torna mais fácil aos programas de cache, dando-lhes uma saída determinista.
#appengine: - Há também limites para o tempo de execução, de CPU e uso de memória, e o programa é restrito a execução em um único segmento (mas pode usar muitas goroutines).
#appengine:
#appengine: O playground utiliza a versão mais recente e estável de Go.
#appengine:
#appengine: .play prog/tour/sandbox.go

* Pacotes

Cada programa Go é composto de pacotes.

Programas começam rodando pelo pacote `main`.

Este programa está usando os pacotes com caminhos de importação `"fmt"` e `"math"`.

Por convenção, o nome do pacote é o mesmo que o último elemento do caminho de importação.

#appengine: *Nota*: o ambiente em que esses programas são executados é
#appengine: determinístico, então rand.Intn sempre retornará o mesmo número.
#appengine:
#appengine: (Para ver um número diferente, a semente do gerador de números; veja [[http://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play prog/tour/packages.go

* Importações

Este grupo de códigos em parênteses da importação, é a declaração de importação "consignada". Você também pode escrever várias declarações de importação assim:

	import "fmt"
	import "math"

.play prog/tour/imports.go

* Nomes exportados

Depois de importar um pacote, você pode consultar os nomes que exporta.

Em Go, um nome é exportado se começa com uma letra maiúscula.

`Foo`  é um nome exportado, assim como `FOO`.
O nome `foo` não é exportado.

Execute o código. Em seguida, renomeie `math.pi` para `math.Pi` e tente novamente.

.play prog/tour/exported-names.go

* Funções

A função pode ter zero ou mais argumentos.

Neste exemplo, `adicione` dois parâmetros do tipo `int`.

Observe que o tipo vem _após_ o nome da variável.

(Para saber mais sobre o porquê dos tipos serem assim, consulte o [[http://golang.org/doc/articles/gos_declaration_syntax.html][artigo sobre a sintaxe de declaração de Go]].)

.play prog/tour/functions.go

* Funções continuação

Quando dois ou mais consecutivos parâmetros da função nomeados compartilhar um tipo, você pode omitir o tipo de todos, menos o último.

Neste exemplo, vamos encurtar
	x int, y int

para

	x, y int

.play prog/tour/functions-continued.go

* Resultados Múltiplos

Uma função pode retornar qualquer número de resultados.

Esta função retorna duas strings.

.play prog/tour/multiple-results.go

* Resultados nomeados

Funções têm parâmetros. Em Go as funções podem retornar vários "parâmetros de resultado", e não apenas um único valor. Eles podem ser nomeados e atuam como variáveis.

Se os parâmetros de resultado são nomeados, uma  declaração `return` sem argumentos retorna os valores atuais dos resultados.

.play prog/tour/named-results.go

* Variáveis

A instrução `var` declara uma lista de variáveis, como em listas de argumentos de função, o tipo é passado.

.play prog/tour/variables.go

* Variáveis com inicializadores

A declaração var pode incluir inicializadores, uma por variável.

Se um inicializador está presente, o tipo pode ser omitido; a variável terá o tipo do inicializador.

.play prog/tour/variables-with-initializers.go

* Declarações curtas de variáveis

Dentro de uma função a instrução de atribuição curta `:=` pode ser utilizada em lugar de uma declaração `var` com o tipo implícito.

(Fora de uma função cada estrutura começa com uma palavra-chave e não é possível usar o `:=`)

.play prog/tour/short-variable-declarations.go

* Tipos básicos

Os tipos básicos de Go são

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // pseudônimo para uint8

	rune // pseudônimo para int32
	     // representa um ponto de código Unicode

	float32 float64

	complex64 complex128

.play prog/tour/basic-types.go

* Constantes

Constantes são declaradas como variáveis, mas com a palavra-chave `const`.

Constantes podem ser seqüências de caracteres, booleanos, ou valores numéricos.

.play prog/tour/constants.go

* Constantes Numéricas

As constantes numéricas são _valores_ de alta precisão.

Uma constante sem tipo tem o tipo necessário para o seu contexto.

Tente imprimir `needInt(Big)` também.

.play prog/tour/numeric-constants.go

* For

Go tem apenas uma estrutura de laço, o `for`.

O `for` básico parece com o que o de C ou Java fazem, exceto que as `(`)` se foram (não são nem mesmo opcionais) e os `{`}` são obrigatórios.

.play prog/tour/for.go

* For continuação

Como em C ou Java, você pode deixar as declarações do começo e do final vazias.

.play prog/tour/for-continued.go

* For é o "while" de Go

Nesse ponto, você pode tirar as vírgulas: o `while` do C é escrito com `for` em Go.

.play prog/tour/for-is-gos-while.go

* Para sempre

Se você omitir a condição do laço, ele executará para sempre, e assim um loop infinito é compactadamente expresso.

.play prog/tour/forever.go

* If

A declaração `if` parece com o que o de C ou Java fazem, exceto que as `(`)` se foram (não são nem mesmo opcionais) e os `{`}` são obrigatórios.

(Parece familiar?)

.play prog/tour/if.go

* If com uma curta declaração

Como o `for`, a instrução `if` pode começar com uma breve declaração antes de executar a condição.

Variáveis ​​declaradas pela instrução são válidas somente no escopo até o final do `if`.

(Tente usar `v` na última instrução `return`.)

.play prog/tour/if-with-a-short-statement.go

* If e else

Variáveis ​​declaradas dentro de uma instrução `if` curta também estão disponíveis dentro dos blocos `else`.

.play prog/tour/if-and-else.go

* Exercício: Laços e Funções

Como uma forma simples de brincar com as funções e laços, implemente a função de raiz quadrada usando o método de Newton.

Neste caso, o método de Newton é aproximar `Sqrt(x)`, escolhendo um ponto de partida _z_ e depois repetindo:

.image static/newton.png

Para começar, basta repetir esse cálculo 10 vezes e ver o quão perto você chega à resposta para vários valores (1, 2, 3, ...).

Em seguida, altere a condição do laço para parar uma vez que o valor deixou de mudar (ou apenas mudanças por um delta muito pequeno). Veja se isso são muitas ou poucas iterações. Como ainda falta para o [[http://golang.org/pkg/math/#Sqrt][math.Sqrt]]?

Dica: para declarar e inicializar um valor de ponto flutuante, dê-lhe a sintaxe de ponto flutuante ou use uma conversão:

	z := float64(1)
	z := 1.0

.play prog/tour/exercise-loops-and-functions.go

* Structs

A `struct` é uma coleção de campos.

(E uma declaração `type` faz o que você esperaria.)

.play prog/tour/structs.go

* Campos Struct

Campos Struct são acessados ​​através de um ponto.

.play prog/tour/struct-fields.go

* Ponteiros

Go tem ponteiros, mas não a aritmética de ponteiros.

Campos struct podem ser acessados ​​através de um ponteiro struct. A indireção através do ponteiro é transparente.

.play prog/tour/pointers.go

* Struct literais

A struct literal denota um valor struct recém-alocado, ao enumerar os valores de seus campos.

Você pode listar apenas um subconjunto de campos usando o `Name:` sintaxe. (E a ordem dos campos nomeados é irrelevante.)

O prefixo especial `&` constrói um ponteiro para uma struct literal.

.play prog/tour/struct-literals.go

* A nova função

A expressão `new(T)` aloca um valor zerado para `T` e retorna um ponteiro para ele.

	var t *T = new(T)

ou

	t := new(T)

.play prog/tour/the-new-function.go

# TODO(campoy): Arrays section

* Slices

Um slice aponta para uma matriz de valores e também inclui um comprimento.

`[]T` é um slice com elementos do tipo `T`.

.play prog/tour/slices.go

* Fatiando slices

Slices podem ser re-fatiados, criando um valor de uma nova slice que aponta para a mesma matriz.

A expressão

	s[lo:hi]

avalia para uma slice de elementos de `lo` através de `hi-1`, inclusive. Assim

	s[lo:lo]

é vazia e

	s[lo:lo+1]

tem um elemento.

.play prog/tour/slicing-slices.go

* Fazendo slices

Slices são criados com a função `make`. Ele funciona através da atribuição de uma matriz zerada e retornando uma slice que se refere a essa matriz:

	a := make([]int, 5)  // len(a)=5

Para especificar uma capacidade, passe um terceiro argumento para `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/tour/making-slices.go

* Slices vazios

O valor zero de uma slice é `nil`.

Uma slice nil tem um comprimento e capacidade de 0.

(Para saber mais sobre as slices, leia o artigo [[http://golang.org/doc/articles/slices_usage_and_internals.html][Slices: usage and internals]] .)

.play prog/tour/nil-slices.go

# TODO(campoy): Appending to slices section

* Range

O `range` do laço `for` itera sobre uma slice ou map.

.play prog/tour/range.go

* Range continuação

Você pode ignorar o índice ou valor, atribuindo o `_`.

Se você só quiser o índice, deixe inteiramente sem o  ", value".

.play prog/tour/range-continued.go

* Exercício: Slices

Implemente `Pic`. Ela deve retornar uma slice de comprimento `dy`, cada elemento do qual é uma slice de `dx` 8-bit inteiros sem sinal. Quando você executa o programa, ele irá exibir a sua imagem, interpretando os números inteiros como escala dos valores de cinza (bem, bluescale).

A escolha da imagem é com você. Funções interessantes incluem `x^y`, `(x+y)/2`, e `x*y`.

(Você precisa usar um loop para alocar cada `[]uint8` dentro do `[][]uint8`.)

(Utilize `uint8(intValue)` para converter entre os tipos.)

.play prog/tour/exercise-slices.go

* Maps

Um map mapeia chaves para valores.

Maps devem ser criados com `make` (não com `new`) antes do uso, o map `nil` está vazio e não pode ser atribuído.

.play prog/tour/maps.go

* Maps literais

Maps literais são como structs literais, mas as chaves são obrigatórias.

.play prog/tour/map-literals.go

* Maps literais continuação

Se o tipo de nível superior é apenas um nome do tipo, você pode omiti-lo a partir dos elementos do literal.

.play prog/tour/map-literals-continued.go

* Mutação de Maps

Inserir ou atualizar um elemento no map `m`:

	m[key] = elem

Recuperar um elemento:

	elem = m[key]

Excluir um elemento:

	delete(m, key)

Teste que uma chave está presente com dois valores:

	elem, ok = m[key]

Se `key` está em `m`, `ok` é `true`. Se não, `ok` é `false` e `elem` tem valor zero pro elemento tipo do map.

Da mesma forma, durante a leitura de um mapa se a chave não estiver presente, o resultado é o valor zero para o tipo de mapa do elemento.

.play prog/tour/mutating-maps.go

# TODO(campoy): Range on maps section

* Exercício: Maps

Implementar `WordCount`. Ele deve retornar um map das contagens de cada &ldquo;word&rdquo; na string `s`. A função `wc.Test` executa um conjunto de testes contra a função fornecida e imprime o sucesso ou falha.
Você pode achar [[http://golang.org/pkg/strings/#Fields][strings.Fields]] útil.

.play prog/tour/exercise-maps.go

* Funções valores

Funções são valores também.

.play prog/tour/function-values.go

* Funções closures

E as funções são closures completos.

A função `adder` retorna um closure. Cada closure é obrigado a própria variável `sum`.

.play prog/tour/function-closures.go

* Exercício: Fibonacci closure

Vamos nos divertir um pouco com as funções.

Implemente uma função `fibonacci` que retorna uma função (um closure) que retorna números sucessivos de Fibonacci.

.play prog/tour/exercise-fibonacci-closure.go

* Switch

Você provavelmente sabia que o `switch` estava chegando.

O bloco case falhará automaticamente, a menos que termine com uma declaração `fallthrough`.

.play prog/tour/switch.go

* Switch com ordem de avaliação

Switch cases avaliam casos de cima para baixo, parando quando um caso for bem-sucedido.

(Por exemplo,

	switch i {
	case 0:
	case f():
	}

não chamar `f` se `i==0`.)

#appengine: *Nota:* Tempo no playground Go sempre aparece para começar às
#appengine: 2009-11-10 23:00:00 UTC, um valor cujo significado é deixado como um
#appengine: exercício para o leitor.

.play prog/tour/switch-evaluation-order.go

* Switch sem condição

Switch sem uma condição é o mesmo que `switch`true`.

Essa estrutura pode ser uma maneira limpa para escrever longas cadeias if-then-else.

.play prog/tour/switch-with-no-condition.go

* Exercício Avançado: raízes cúbicas complexas

Vamos explorar o apoio do Go built-in para os números complexos através dos tipos `complex64` e `complex128`. Para raízes cúbicas, o método de Newton equivale a repetir:

.image static/newton3.png

Encontre a raiz cúbica de 2, só para ter certeza de que o algoritmo funciona. Há uma função [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] no pacote `math/cmplx`.

.play prog/tour/advanced-exercise-complex-cube-roots.go

* Métodos e Interfaces

* Métodos

Go não tem classes. No entanto, você pode definir métodos em tipos struct.

O _método receptor_ aparece em sua lista de argumentos entre a própria palavra-chave `func` e o nome do método.

.play prog/tour/methods.go

* Métodos continuação

Na verdade, você pode definir um método em _qualquer_ tipo que você definir em seu package, e não apenas structs.

Você não pode definir um método em um tipo de um outro pacote, ou em um tipo básico.

.play prog/tour/methods-continued.go

* Métodos com ponteiro receptor

Os métodos podem ser associados com um tipo nomeado ou um ponteiro para um tipo nomeado.

Nós só vimos dois métodos `Abs`. Um no tipo ponteiro `*Vertex` e outro no valor do tipo `MyFloat`.

Há duas razões para usar um receptor de ponteiro. Primeiro, para evitar copiar o valor de cada chamada de método (mais eficiente se o tipo de valor é uma estrutura grande). Em segundo lugar, de modo que o método possa modificar o valor que o seu receptor aponta.

Tente mudar as declarações dos métodos `Abs` e `Scale` para usar `Vertex` como o receptor, ao invés de `*Vertex`.

O método `Scale` não tem efeito sobre `v` é um `Vertex`. `Scale` muda `v`. Quando `v` é um tipo valor (não-ponteiro), o método vê uma cópia do `Vertex` e não pode sofrer mutação do valor original.

`Abs` funciona de qualquer maneira. Ele apenas lê `v`. Não importa se ele está lendo o valor original (através de um ponteiro) ou uma cópia desse valor.

.play prog/tour/methods-with-pointer-receivers.go

* Interfaces

Um tipo de interface é definida por um conjunto de métodos.

Um valor de tipo de interface pode conter qualquer valor que implementa esses métodos.

.play prog/tour/interfaces.go

* Interfaces são satisfeitas implicitamente

Um tipo implementa uma interface através da implementação dos métodos.

_Não_há_declaração_explícita_de_intenções._

As interfaces implícitas dissociam os pacotes de implementação que definem as interfaces: um não depende do outro.

Além disso, incentiva a definição de interfaces precisas, porque você não tem que encontrar todas as implementações e marcá-las com o novo nome de interface.
[[http://golang.org/pkg/io/][Package io]] define `Reader` e `Writer`; você não precisa implementar.

.play prog/tour/interfaces-are-satisfied-implicitly.go

* Erros

Um erro é algo que pode descrever-se como uma string de erro. A idéia é capturada pela predefinida interface built-in, o tipo `error`, com seu método único `Error`, retornando uma string:

	type error interface {
		Error() string
	}

As várias rotinas de impressão no pacote `fmt` que automaticamente sabe chamar o método quando solicitado a imprimir um `error`.

.play prog/tour/errors.go

* Exercício: Erros

Copie o sua função `Sqrt` dos exercícios anteriores e modifique-o para retornar um valor de `error`.

`Sqrt` deve retornar um valor de erro não-nil quando recebe um número negativo, pois não suporta números complexos.

Crie um novo tipo

	type ErrNegativeSqrt float64

e faça-o dar `error`, dando-lhe um

	func (e ErrNegativeSqrt) Error() string

tal método que `ErrNegativeSqrt(-2).Error()` retorne `"cannot`Sqrt`negative`number:`-2"`.

*Nota:* uma chamada para `fmt.Print(e)` dentro do método `Error` irá enviar o programa em um laço infinito. Você pode
evitar isso através da conversão `e` em primeiro lugar: `fmt.Print(float64(e))`. Por que?

Mude sua função `Sqrt` para retornar um valor `ErrNegativeSqrt` quando receber um número negativo.

.play prog/tour/exercise-errors.go

* Servidores Web

O [[http://golang.org/pkg/net/http/][pacote http]] serve requisições HTTP usando qualquer valor que implementa `http.Handler`:

	package http

	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Neste exemplo, o tipo `Hello` implementa `http.Handler`.

Visite [[http://localhost:4000/][http://localhost:4000/]] para ver a saudação.

#appengine: *Nota:* Este exemplo não será executado através da interface web-based
#appengine: do passeio. Para tentar escrever servidores web que você possa querer
#appengine: [[http://golang.org/doc/install/][Install Go]].

.play prog/tour/web-servers.go

* Exercício: manipuladores HTTP

Implementar os seguintes tipos e definir métodos ServeHTTP sobre eles. Registrá-los para lidar com caminhos específicos no seu servidor web.

	type String string

	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Por exemplo, você deve ser capaz de registrar manipuladores usando:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/tour/exercise-http-handlers.go

* Imagens

O [[http://golang.org/pkg/image/#Image][package image]] define a interface `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Veja [[http://golang.org/pkg/image/#Image][a documentação]] para todos os detalhes)

Além disso, `color.Color` e `color.Model` são interfaces, mas vamos ignorar isso usando as implementações predefinidas `color.RGBA` e `color.RGBAModel`.

.play prog/tour/images.go

* Exercício: Imagens

Lembre-se o gerador de imagem que escrevi anteriormente? Vamos escrever outro, mas desta vez ele irá retornar uma implementação de `image.Image` em vez de uma slice de dados.

Definir a seu próprio tipo `Image`, implemente [[http://golang.org/pkg/image/#Image][os métodos necessários]], e chame `pic.ShowImage`.

`Bounds` deve retornar um `image.Rectangle`, como `image.Rect(0,`0,`w,`h)`.

`ColorModel` deve retornar `color.RGBAModel`.

`At` deve retornar uma cor; o valor `v` no gerador última imagem corresponde a `color.RGBA{v,`v,`255,`255}` em um presente.

.play prog/tour/exercise-images.go

* Exercício: Leitor Rot13

Um padrão comum é um [[http://golang.org/pkg/io/#Reader][io.Reader]] que envolve outro `io.Reader`, modificando o fluxo de alguma forma.

Por exemplo, a função [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] recebe um `io.Reader` (um fluxo de dados compactado) e retorna um `*gzip.Reader` que também implementa `io.Reader` (um fluxo de dados descomprimidos).

Implemente um `rot13Reader` que implementa um `io.Reader` que leia a partir de um `io.Reader`,modificando o fluxo através da aplicação da cifra [[http://en.wikipedia.org/wiki/ROT13][ROT13]] de substituição para todos os caracteres alfabéticos.

O tipo `rot13Reader` é fornecido para você. Você deve torná-lo um `io.Reader` através da implementação de seu método `Read`.

.play prog/tour/exercise-rot-reader.go

* Concorrência

* Goroutines

Uma _goroutine_ é um segmento leve e gerenciado pelo runtime de Go.

	go f(x, y, z)

inicia uma nova execução goroutine

	f(x, y, z)

A avaliação de `f`, `x`, `y`, e `z` acontece na goroutine corrente e para a execução de f acontece em uma goroutine nova.

Goroutines executam no mesmo espaço de endereço, para que o acesso à memória compartilhada seja sincronizada. O pacote [[http://golang.org/pkg/sync/][sync]] fornece as primitivas úteis, embora você não vá precisar muito deles em Go, pois há outras primitivas. (Veja o próximo slide).

.play prog/tour/goroutines.go

* Canais

Canais são um conduto tipado através do qual você pode enviar e receber valores com o operador de canal, `<-`.

	ch <- v    // v envia para o canal ch.
	v := <-ch  // Recebe do ch, e
	           // atribui o valor de v.

(Os dados fluem na direção da seta.)

Como maps e slices, os canais devem ser criados antes de se usar:

	ch := make(chan int)

Por padrão, enviam e recebem bloco até o outro lado estar pronto. Isso permite que goroutines sincronizem sem bloqueios explícitos ou variáveis ​​de condição.

.play prog/tour/channels.go

* Canais Bufferizados

Os canais podem ser _bufferizados_. Fornecendo o tamanho do buffer como o segundo argumento para `make` para inicializar um canal bufferizado:

	ch := make(chan int, 100)

Envia para um bloco de canais bufferizados apenas quando o buffer está cheio. Recebe bloco quando o buffer está vazio..

Modifique o exemplo, enchendo o buffer e veja o que acontece.

.play prog/tour/buffered-channels.go

* Range e Close

Um remetente pode `close` um canal para indicar que os valores não serão mais enviados. Receptores podem testar se um canal foi fechado através da atribuição de um segundo parâmetro para a expressão de recepção: depois

	v, ok := <-ch

`ok` é `false` se não há mais valores a receber e o canal está fechado.

O laço `for`i`:=`range`c`  recebe valores do canal repetidamente até que seja fechado.

*Nota:* Apenas o remetente deve fechar um canal, nunca o receptor. O envio em um canal fechado irá causar um pânico.

*Outra*nota*: Canais não são como arquivos, você geralmente não precisa fechá-los. O encerramento só é necessário quando o receptor precisa saber que não há mais valores chegando, como para terminar um laço `range`.

.play prog/tour/range-and-close.go

* Select

A instrução `select` permite uma espera na goroutine sobre as operações de comunicação múltiplas.

O bloco `select` aguarda até que um de seus cases possam executar, então ele executa esse case. Ele escolhe um ao acaso se vários estiverem prontos.

.play prog/tour/select.go

* Selection Padrão

O case `default` em um `select`  é executado se nenhum outro caso está pronto.

Utilize um case `default` para tentar um enviar ou receber sem bloqueio:

	select {
	case i := <-c:
		// use i
	default:
		// recebendo c bloquearia
	}

.play prog/tour/default-selection.go

* Exercício: árvores binárias equivalentes

Pode haver muitas árvores binárias diferentes com a mesma seqüência de valores armazenados nas folhas. Por exemplo, aqui estão duas árvores binárias que armazenam a seqüência 1, 1, 2, 3, 5, 8, 13.

.image static/tree.png

A função para verificar se duas árvores binárias armazenam a mesma seqüência é bastante complexa, na maioria das linguagens. Vamos usar a simultaneidade de Go e canais para escrever uma solução simples.

Este exemplo utiliza o pacote `tree`, o qual define o tipo:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}

* Exercício: árvores binárias equivalentes

*1.* Implemente a função `Walk`.

*2.* Teste a função `Walk`.

A função `tree.New(k)` constrói uma árvore binária aleatoriamente estruturada segurando os valores `k`, `2k`, `3k`, ..., `10k`.

Crie um novo canal `ch` e lance o walker:

	go Walk(tree.New(1), ch)

Então leia e imprima 10 valores do canal. Deve ser os números 1, 2, 3, ..., 10.

*3.* Implementar a função `Same` usando `Walk` para determinar se `t1` e `t2` armazenam os mesmos valores.
*4.* Teste a função `Mesma`.

`Same(tree.New(1),`tree.New(1))` deve retornar true, e `Same(tree.New(1),`tree.New(2))` deve retornar false.

.play prog/tour/exercise-equivalent-binary-trees.go

* Exercício: Web Crawler

Neste exercício, você vai usar os recursos da concorrência de Go para paralelizar um web crawler.

Modifique a função `Crawl` para buscar URLs em paralelo, sem buscar a mesma URL duas vezes.

.play prog/tour/exercise-web-crawler.go

* Para onde ir a partir daqui...

#appengine: Você pode começar por
#appengine: [[http://www.golangbr.org/doc/instalacao][instalando Go]] ou baixar o
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]].

#appengine: Uma vez que você tenha Go em sua máquina, a [[http://golangbr.org/doc/][Documentação Go]] é um ótimo lugar para
#appengine: continuar.
começar.
Ela contém referências, tutoriais, vídeos, e muito mais.

Para aprender como organizar e trabalhar com código Go, veja [[http://www.youtube.com/watch?v=XCsL89YtqCs][este screencast]] ou leia  [[http://golangbr.org/doc/codigo][Como escrever código Go]].

Se precisar de ajuda com a biblioteca padrão, consulte a [[http://golangbr.org/pkg/][referência de pacotes]]. Para obter ajuda com a linguagem em si, você pode ser surpreendido ao encontrar a [[http://golangbr.org/ref/spec][Especificação da Linguagem]], é bastante compreensivel.

Para explorar ainda mais a concorrência no modelo de Go, consulte a [[http://golang.org/doc/codewalk/sharemem/][Share Memory by Communicating]] codewalk.

O [[http://golang.org/doc/codewalk/functions/][First Class Functions in Go]] codewalk dá uma perspectiva interessante sobre tipos de funções em Go.

O [[http://blog.golang.org/][Go Blog]] tem um grande arquivo de artigos informativos de Go. Além do [[http://blog.golangbr.org/][Blog Golang Brasil]] da comunidade brasileira.

Participe da lista de discussão brasileira [[http://groups.google.com/group/golang-brasil][Golang Brasil]].

Visite [[http://golangbr.org][golangbr.org]] para mais.

